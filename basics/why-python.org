#+title: Choosing Python for rapid prototyping/drafting

* 15:54, MONDAY-JAN-11-2021 | @CA

I have been thinking over the past 2 days about picking up another language as my main working language.  C++ is great for all of its deep and well-defined rules (? ^1), but its development time is way too long.  I need a high-level language that can allow me /to do more things/ in a given amount of time instead of /spending all of my time on one single task/.


I think Python is a good choice for the following reasons:

*** 1. Popularity
Popularity means accessibility.  Being popular means that it's easy enough to learn for many people.  This implies a shorter learning curve and faster implementation of ideas.

*** 2. A concise language
Its syntax is trimmed to favor rapid prototyping.  In other words, I spend less energy and attention on working my keyboard to write and navigate code blocks as compared to C++.

Because of the overly protective nature of C++, even the background task of guarding the code is given to the readers.  The author, once gotten into the /flow/ state while coding, simply treats it as an automated task running in the background.  Still a /resource intensive/ background task to be sure when compared to high-level languages like Python, Scala or Kotlin (^2).

However, for the reader, it takes even more energy to parse through all the background noise.  The reader has to decipher the *author's intention* through a soup of curly braces, pointers, references, the often times cryptically-written variable names etc.  It's a non-trivial energy expenditure that could have been better spent on meditating about *the ideas behind the code*.

*** 3. Personal limitations & goal
As a major-switcher, I simply do not have the wealth of experience that can only be gained through years of continuous coding.  This is the *10,000-hour mark* often mentioned by veteran programmers.  Effort alone cannot cover for that.  This is a fact that is deeply tied to reality itself.

There are natural and biological limits to what a person can do rapidly in a given amount of time.  These limits make up the /upper bound/ for the algorithm of rapid-learning, to put it in computer-science terms.  For example, there are edge cases and irregularities that can only be learned through encountering and solving accidents.  Systematic absorption of knowledge only helps in erecting the framework.  It requires experience to become a good engineer.

That being said, /ingenuity/ and /resourcefulness/ can help in closing the gap.  However, how much of the gap is left depends largely on how well time and attention are managed.  This is highly subjective to the individuals.  In other words, what separate the wheat from the chaff is /discipline/ and the /clever management of time and attention/.  It works like a feedback loop.  The more one learns and gains experience through /soaking up knowledge/ and /applying the learned knowledge into real projects/, the more the two actions feed on each other and produce a compound effect.  This effect is what propels the proactive learner up above the average majority.


Personally speaking, I am aware of my limitations, so I know I must work harder to cover for what I fall short.  For this reason, I consider my current college attendance to be a /pay-to-access/ subscription to essential topics.  It is a great investment.

I am well aware that the overarching attitude about college for most students is that it is where you go to have fun and get a degree.  Most people just do their own things to kill time and fill in the hours while in college, because they are young and they have no idea what they are doing.  Therefore, one cannot expect too much of the quality of education one get /by default/.  One /must/ be proactive in one's own investigation and research to be accomplished in life, and this applies equally to college.

I have a goal that I must accomplish.  I cannot waste time.  Thus, I am willingly sacrificing the need for entertainment (? ^3) to dedicate all of my attention into learning and honing my *programming & engineering skills*.  Still largely an outsider at the moment, I simply don't know enough about the landscape of the software engineering world.  Therefore, I need a gateway leading to the essential ideas underlying the /professional/ layer of this field.  I need an entry-point.  This entry point is not afforded to most /ad hoc/ learners (bootcampers and hobby programmers).

Knowing how to use a concise high-level language is tremendously helpful in this process.  A language with concise syntax is an amazing tool in /mapping out knowledge/ rapidly and efficiently.

*Thus, learning Python is the most appropriate choice going forward.*


* UPDATE: REVISION & PERSONAL NOTES.  21:35, TUESDAY-AUG-03-2021 | @CA
^1.
This is a funny remark because of how /naive/ I was.  C++ is not a language with well-defined rules.  In fact, it is a horrible choice for applications that need rapid scaling.  It requires too large an up-front investment of attention from the learner.  Having come into contact with Java, I can see why Java is much more popular.  Java doesn't try to do everything.  It gave up the low-level control to focus instead on achieving a uniform code standard, which over years have come to be known as /best practices/.  Java focuses on the high-level, where the vast majority of professional developers actually operate.  It organize the high-level business-oriented ideas and enterprise-class patterns into very well-defined policies.  These ideas and patterns are composed into what is now known as /Object-Oriented Programming Principles/.


^2.
This is a note on how far I have expanded for the past 8 months.  I now know that there are other high-level languages, both /general-purpose/ (GPL) and /domain-specific/ (DSL).  Python, Scala and Kotlin are of the first category.  Groovy is of the latter.

Interestingly, except for Python, the other three are based (and capable of running interop with Java) on the JVM (the Java Virtual Machine).  Quite frankly, Python code is also executed by the Python interpreter, which is a similar model to the JVM, i.e. the philosophy of 'Write Once, Run Anywhere'.  Furthermore, Python applies heavily the OOP in its code base in the form of classing and subclassing.

These reasons are perhaps why Python has become extremely popular, just like Java previously did.


^3.
This is more of a meta topic.  As it turned out, I don't need entertainment all that much.  I grew up in a world of excessive distractions specifically designed to monetize attention.  For that reason, I /thought/ that I need entertainment.  I do not.


** Some more crystalized thoughts
Revisiting a note I wrote 8 months ago really put into perspective how much I have changed so far.  Quality knowledge is incredibly expensive.  Some people go through their entire life mostly blind to the flow of information constantly and vigorously fluctuating around them, and that is really sad.

I am grateful that I have gotten this chance to learn to handle information.  I am not letting it go.

After 8 months, I can say certainly that I have mastered Python beyond the beginner level.  I have stepped into the high-intermediate level.  From here on, it requires advanced meta-knowledge in design patterns in order to break into the advanced level.  This is required for all languages, not just Python.  These meta-knowledge can only be acquired through built-up experience and continous learning.

/I have gotten a solid foundation.  Now it is time to build on top of it./
